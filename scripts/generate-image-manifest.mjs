import { readdirSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");
const IMAGES_DIR = join(ROOT, "app", "assets", "images");
const OUTPUT_PATH = join(IMAGES_DIR, "product-images.ts");
const SUPPORTED_EXTENSIONS = new Set([
  ".jpg", ".jpeg", ".png", ".svg", ".webp", ".avif",
]);

/**
 * Scans app/assets/images/ for files matching the [product_id]_[number].[ext] pattern.
 * Generates a TypeScript file that imports each image and exports a mapping
 * of product IDs to their imported image arrays (sorted by number).
 *
 * Example output (product-images.ts):
 *   import img_0 from "./brass-birmingham_1.jpg";
 *   import img_1 from "./brass-birmingham_2.jpg";
 *   ...
 *   const productImages = { "brass-birmingham": [img_0, img_1] };
 *   export default productImages;
 */
function generateProductImages() {
  let files;
  try {
    files = readdirSync(IMAGES_DIR);
  } catch {
    console.log("No app/assets/images/ directory found. Creating empty file.");
    writeEmptyFile();
    return;
  }

  const entries = [];

  for (const file of files) {
    const dotIndex = file.lastIndexOf(".");
    if (dotIndex === -1) continue;

    const ext = file.slice(dotIndex).toLowerCase();
    if (!SUPPORTED_EXTENSIONS.has(ext)) continue;

    const baseName = file.slice(0, dotIndex);
    const underscoreIndex = baseName.lastIndexOf("_");
    if (underscoreIndex === -1) continue;

    const num = baseName.slice(underscoreIndex + 1);
    if (!/^\d+$/.test(num)) continue;

    const productId = baseName.slice(0, underscoreIndex);
    if (!productId) continue;

    entries.push({ productId, file, order: parseInt(num, 10) });
  }

  entries.sort((a, b) => {
    const cmp = a.productId.localeCompare(b.productId);
    return cmp !== 0 ? cmp : a.order - b.order;
  });

  const imports = [];
  const productMap = {};

  entries.forEach((entry, i) => {
    const varName = `img_${i}`;
    imports.push(`import ${varName} from "./${entry.file}";`);

    if (!productMap[entry.productId]) {
      productMap[entry.productId] = [];
    }
    productMap[entry.productId].push(varName);
  });

  const mapEntries = Object.entries(productMap)
    .map(([id, vars]) => `  "${id}": [${vars.join(", ")}]`)
    .join(",\n");

  const lines = [
    "// AUTO-GENERATED by scripts/generate-image-manifest.mjs",
    "// Run `npm run generate-images` to regenerate. Do not edit manually.",
    "",
  ];

  if (imports.length > 0) {
    lines.push(...imports, "");
  }

  lines.push(
    "type ImageImport = { src: string; width: number; height: number };",
    "",
    `const productImages: Record<string, ImageImport[]> = {`,
    mapEntries || "",
    "};",
    "",
    "export default productImages;",
    ""
  );

  writeFileSync(OUTPUT_PATH, lines.join("\n"));

  const productCount = Object.keys(productMap).length;
  const imageCount = entries.length;
  console.log(
    `Product images: ${imageCount} images for ${productCount} products â†’ ${OUTPUT_PATH}`
  );
}

function writeEmptyFile() {
  const content = [
    "// AUTO-GENERATED by scripts/generate-image-manifest.mjs",
    "// Run `npm run generate-images` to regenerate. Do not edit manually.",
    "",
    "type ImageImport = { src: string; width: number; height: number };",
    "",
    "const productImages: Record<string, ImageImport[]> = {};",
    "",
    "export default productImages;",
    "",
  ].join("\n");
  writeFileSync(OUTPUT_PATH, content);
}

generateProductImages();
